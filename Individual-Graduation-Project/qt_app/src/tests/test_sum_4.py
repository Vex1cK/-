# -*- coding: utf-8 -*-
import torch
from transformers import T5ForConditionalGeneration, T5Tokenizer
tokenizer = T5Tokenizer.from_pretrained("cointegrated/rut5-base-multitask")
model = T5ForConditionalGeneration.from_pretrained("cointegrated/rut5-base-multitask")

def generate(text, **kwargs):
    inputs = tokenizer(text, return_tensors='pt')
    with torch.no_grad():
        hypotheses = model.generate(**inputs, num_beams=5, **kwargs)
    return tokenizer.decode(hypotheses[0], skip_special_tokens=True)

text =  """Мерион Академи, платформа доступного образования. Ой-ой, кажется нас посетила полиция проверки подписки. В этот раз обойдемся без страпа, но на нашу телегу обязательно подпишитесь. Когда-нибудь задумывался, что стоит за работой любимого сайта? Если задумывался, то круто, что ты открыл это видео, а если нет, то задумайся прямо сейчас и продолжай смотреть. Начнем с того, что любой сайт это просто набор html файлов, стилей и картинок. файлы нам надо как-то получить, чтобы страница появилась у нас или, как еще говорят, отрендерилась. Наш комплюктор сказал серверу, слушай, друг, а у тебя есть немножко файлов для этой страницы? А сервер такой, да, у меня есть немного, вот, держи. В этот момент, когда ты открыл это видео, от тебя на сервер отправился запрос специального формата, с помощью которого сервер понимает, что пользователь от него хочет. Этот запрос называется http-запросом. Чтобы лучше понимать то, о чем мы сейчас будем говорить, наши видео про http и https больше знаешь больше знаешь как говорится и тут вроде все просто но главный вопрос как сервер узнал где лежат файлы как он вообще ответил нашему куда хтеру а все благодаря веб-серверу специальной программе который живет на сервере отправка сообщения другу из саратова покупка носков с енотами в интернет-магазине покупка классных курсов на сайте мере накидами все что ты делаешь сайтом проходит через него погоди веб-сервер и сервер это не одно и то же не совсем запоминай дружок веб сервер эта программа а сервер это компьютер где эта программа установлена без этой программы мы бы не смогли пользоваться интернетом так как мы им пользуемся сейчас сейчас поясним как это работает есть клиенты это пользователи нашего сайта эти клиенты отправляют и сетепи запрос а веб-сервер принимает его кидает клиенту и сетепи ответ который содержит уже саму страницу за всей нужной информации окей с тем что такое веб-сервер мы разобрались, лягушонок. И одновременно, незаметно для себя, разобрались с тем, что такое Nginx, Nginx, Nginx Nginx. Как эту штуку только не называют. Но как бы ее ни называли, смысл от этого не меняется. Это один из самых топовых веб-серверов с открытым исходным кодом, на котором работает очень большая доля сайтов в этих ваших интернетах. А написан он, как и много других серьезных штук, на языке C. Nginx? Да-да, официально он называется именно так. как и любой веб-сервер, это своеобразная прослойка между пользователями, пришедшими из интернета, и железками сервера. Теоретически звучит классно, но как с этим работать? Сейчас разберёмся. Перед тем, как использовать Nginx, его нужно установить на свой комплюктор, который будет выполнять роль сервера. Как только установишь, вбей IP-адрес своего сервера в адресную строку браузера, и если видишь такую картинку, значит всё ок, и Nginx работает. Да, вот так просто. Но теперь нам надо его настроить для конкретного сайта, а то сейчас что-то не то. Для этого разберемся с тем какие папки и файлы есть у Nginx. В первой папке лежат файлы сайта по твоему домену, просто так она не появится, ее нужно создать, например, с помощью такой команды. Последняя директория в пути должна иметь название как и у твоего домена, чтобы не запутаться. Во второй папке лежит главный файл настроек Nginx, а здесь мы пишем конфигурации для сайтов. Так, из этого списка нас интересует директория sites-available, где мы создадим файл конфигурации, то есть настроек, для нашего будущего сайта. Обрати внимание, что в названии добавляется расширение для конфигурации .conf. После того, как мы сделали этот файл, пора его написать. Откроем его и рассмотрим простейшую конфигурацию. В файле нужно создать блок сервер. Внутри него пропишем, что сервер ждет запросы пользователей на порту 80. Еще говорят, что веб-сервер слушает порт 80. Если что, то этот виртуальный порт можно представить как обычный порт у компьютера, куда подключаются пользователи. Только этих портов может быть очень много. В строчке server name пропишем домен нашего сайта yourdomain.ru. Тогда веб-сервер будет ожидать запросы, адресованные к этому домену. Потом мы добавляем блок location. В нем добавим строчку root, где пропишем будь до файла сайта. Когда придет запрос, сервер будет искать файлы для сайта в этой директории. В строчке index напишем название главного HTML-файла. Его принято называть index.html. Когда ты перейдешь по основному адресу нашего домена, который обозначается как slash, то сервер отдаст именно этот файл index.html. А что делать, если сайт многостраничный? Не переживай, уже после такой конфигурации все страницы будут работать. В ней только указано то, что за главную страницу отвечает файл index.html. Такая настройка очень простая, но для настоящих сайтов не подойдет. Nginx не знает про статический контент, то есть картинки или стили, которые одинаковы для всех пользователей. Кстати, есть еще и динамический контент, он отличается для каждого пользователя. Например, профиль пользователя на сайте, где для каждого юзера отображаются разные аватарки и имена. Так вот, если ты перейдешь на страницу как есть, то увидишь, что страница выглядит так, как будто это только имена. Например, профиль по... ...пользователя на сайте, где для каждого юзера отображаются разные аватарки и имена. Так вот, если ты перейдешь на страницу как есть, то увидишь, что страница выглядит так, как будто ты только что изобрел машину времени и отправился в прошлое. Нам нужно сделать так, чтобы сайт выглядел красиво и на нем были картинки. Давай немного усложним конфиг и добавим вторую строчку location. В ней перечислим все виды статического контента и укажем, где он лежит. И теперь наш сайт может показывать пользователю картинки и вообще выглядит сногсшибательно. Но это еще не все. Как минимум потому, что сейчас все сайты работают по защищенному протоколу HTTPS. а это конфигурация для http, протокола, который не шифруется. Браузер сразу начнет ругаться на такой сайт. Для шифрования нужен специальный сертификат, который называют SSL или TLS. Бывают разные виды, но если твой сервис это не BigTech, то будет достаточно бесплатного сертификата Let's Encrypt. Получив этот сертификат, можно добавить его на сервер. Сделаем такую конфигурацию, которая будет переадресовывать пользователя сразу с http на https. Теперь секции Server 2. Первая секция Server просто переводит или, как говорят, редиректит на HTTP соединение с помощью оператора Return. Цифра 301, кстати, говорит как раз об этом редиректе. В новой секции Server мы указали, что теперь сайт открывается по порту 443. Это тоже важно, ведь большинство сайтов в интернете с безопасным соединением открываются именно по нему. Потом указан сам сертификат и ключ, который будет шифровать информацию. Классно? Классно. Больше браузер не ругается. Но мы все еще не заканчиваем. Слышал про то, что сайт должен загружаться до 255 миллисекунд, чтобы пользователь не ругался? Вот теперь слышал. И первый способ приблизиться к этой цели — сохранить информацию, которую уже загружал пользователь, а потом показывать ее, не загружая повторно. Это называется кэширование, от английского слова «cache». Но не тот, о котором ты подумал. И даже не этот. Часто используется кэширование на стороне сервера, но это сложно и не всегда надо. Мы будем использовать кэширование у пользователя, чтобы браузер сам сохранял всю информацию, которую уже видел. Для этого добавляем строчку expires1d в блок, где мы добавляли статические файлы. 1d означает, что кэш будет храниться один день, и все, все работает. При такой конфигурации пользователь не даст нам по жопе за то, что у него долго загружается страница сайта, а браузер не будет кричать о том, что у нашего сайта незащищенное соединение, и даже картинки загрузятся без проблем. Ну и быстренько скажем про nginx.conf. Помнишь про него? Там, где лежат главные настройки. Он может выглядеть вот так. Что тут есть интересного? В первой строчке User написан пользователь, который будет использовать Nginx. Вторая строчка Worker Processes отвечает за количество ядер процессора, которые будут обрабатывать подключение. Если указано Auto, то будут выбираться автоматически. Worker Connections указывает на количество одновременных подключений к веб-серверу. И еще есть строчка JZipOn, включает сжатие файлов при загрузке. Это ускоряет отправку файлов пользователю благодаря снижению их размера. Ну и вообще много чего интересного можно покрутить. Что ж, дружок, теперь ты знаешь, что Nginx может самостоятельно принимать, обрабатывать и отдавать пользователям то, чего они попросили. Прикольно, что он каждый запрос делит на небольшие соединения и обрабатывает несколько таких соединений параллельно. То есть он асинхронный. После выполнения все они сливаются в единый блок и возвращаются в качестве ответа. Это делает его быстрым и прост красавчиком. Во всяких больших проектах для обработки запросов пользователя обычно используют микросервисы. Тут Nginx проигрывает, потому что он плохо справляется с такими запросами. Во-первых, он работает только с протоколом HTTP, но иногда для микросервисов нужны другие протоколы, например, gRPC. Во-вторых, часто нужны сложные сценарии маршрутизации, то есть перенаправления запросов. Nginx справляется с маршрутизацией, но у него есть ограничения. В-третьих, иногда нужны более масштабируемые инструменты, которые специально созданы для микросервисов, например, Linkerd. Но про него все равно не забывают. Он может быть балансировщиком нагрузки, то есть своеобразным пересыльщиком, который принимает запрос от клиента, передает его какому-нибудь серверу для обработки, получает ответ от сервера и отправляет пользователю. Причем он определяет, какой сервер сейчас загружен меньше всего и обращается именно к нему. В таком случае сервисы не перегружаются, а только максимально быстро их обрабатывают. Пример, который сейчас на экране, не настоящий, но похож на него. В строчке proxy-pass мы прописали IP-адрес основного сервера, и таким образом запросы будут пересылаться на него. Сервер, который пересылает запросы еще называют обратным прокси-сервером. Понятно, что Nginx не один такой. Когда говорят про Nginx, сразу вспоминается его главный конкурент — Apache. Nginx был разработан программистом Игорем Сысоевым в 2004 году, и он изначально создавал его как альтернативу популярному тогда Apache, чтобы быстрее обрабатывать статичный контент. Получается, герой нашего сегодняшнего видео превосходит Apache в работе со статическим контентом, поэтому он отлично подходит для блогов, лендингов и страниц интернет-магазинов. То есть, по сути, для большинства сайтов в интернете. Но он проигрывает Apache в работе с динамическим контентом, тем, который генерируется специально для клиента. Хоть это противостояние и выглядит как война, но никто не запрещает использовать Nginx и Apache вместе. Статичные файлы и фронтенд, то есть весь внешний вид сайта, работают на Nginx, а бэкэнд, то есть внутренние шестерёнки сайта, которые пишут на PHP, Node.js, Go или Python, работают на Apache. Таким образом, статичные файлы будут быстро загружаться, а бэкэнд станет легче настраиваться. Ставь лайк, если хочешь видос Apache против Nginx. Кстати, не менее интересное противостояние случилось у Nginx с компанией Rambler. Дело в том, что Игорь Сысоев придумал и разработал Nginx, являясь на тот момент сотрудником Rambler, а значит, посчитали там. И все права на Nginx принадлежат Rambler. А это означало бы, что Nginx перестал бы быть open-source. Такого интернет стерпеть не смог, и понеслось. В поддержку Nginx вступили Яндекс, ВК, 2GIS, Озон и куча других IT-компаний и ресурсов. А некоторые владельцы сайтов даже устроили небольшой блокаут, поместив на главные страницы вот такие заглушки. В итоге Rambler отозвал все претензии. Кстати, ранее, до всей этой свистопляски, компания F5 Networks купила Nginx за 670 миллионов долларов. И после этого всё это и началось. Совпадение? Не думаю. Фух, сколько всего классного было в этом видео, да? А хочешь научиться во всех этих приколюшках шарить? Ну тогда приходи на наш курс по Linux, где мы будем поднимать и настраивать веб-серваки и не только. Еще почтовый и файловый и докер, и докер посмотрим и Zabbix. Записывайся на вводный урок по ссылочке в описании. А под конец как всегда вопрос. Файлы JavaScript это динамический или статический контент? Ответ"""

print(generate('simplify | ' + text, max_length=500, min_length=200))
